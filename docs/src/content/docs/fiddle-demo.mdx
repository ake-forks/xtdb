---
title: Fiddle Demo
pagefind: false
---

import Fiddle from '@components/fiddle.astro';
import Txs from '@components/fiddle/txs.astro';
import Query from '@components/fiddle/query.astro';

Allows you to embed a miniature instance of [xt-fiddle](https://fiddle.xtdb.com) in the docs, with a couple added features as a bonus!

## Basic Usage

You can add a `Fiddle` to the page with pre-set transactions & query like so:

<Fiddle>
  <Txs txs="INSERT INTO docs (xt$id, foo) VALUES (1, 'one');" />
  <Query q="SELECT * FROM docs" />
</Fiddle>

If you want to preserve whitespace you can do this:

<Fiddle>
  <Txs txs="INSERT INTO docs (xt$id, foo) VALUES (1, 'one');" />
  <Query q={
`SELECT docs.xt$id, docs.foo
  FROM docs
-- You can also put comments :)`}
/>
</Fiddle>

## Hide editors

Sometimes you just want to show of the query, you can hide the transactions like so:

<Fiddle>
  <Txs hidden={true}
       txs="INSERT INTO docs (xt$id, foo) VALUES (1, 'one');" />
  <Query q="SELECT * FROM docs" />
</Fiddle>


You can do the same with the query of course:

<Fiddle>
  <Txs txs="INSERT INTO docs (xt$id, foo) VALUES (1, 'one');" />
  <Query hidden={true} q="SELECT * FROM docs"/>
</Fiddle>

## AutoLoad

You can tell Fiddle to load it's results on page load by using the `autoLoad` property:

<Fiddle autoLoad>
  <Txs txs="INSERT INTO docs (xt$id, foo) VALUES (1, 'one');" />
  <Query q="SELECT * FROM docs"/>
</Fiddle>

This is particularly useful for [Templated Queries](#templated-queries) as we'll see below.

## Errors

If you have an error in the transactions/query it looks like this:

<Fiddle autoLoad>
  <Txs txs="INSERT INTO docs (xt$id, foo) VALUES (1, 'one');" />
  <Query q="SELECT * FOM docs" />
</Fiddle>

## System Time

You can set system time on a transaction like so:

<Fiddle>
  <Txs systemTime="2020-01-01"
       txs="INSERT INTO docs (xt$id, name) VALUES (1, 'one');" />
  <Query q="SELECT * FROM xt$txs" />
</Fiddle>

## Multiple Transactions

It can be useful to include multiple "batches" of transactions.
Particularly for showing of valid time & system time:

<Fiddle>
  <Txs systemTime="2020-01-01"
       txs="INSERT INTO docs (xt$id, name) VALUES (1, 'one');" />
  <Txs systemTime="2020-01-02"
       txs="INSERT INTO docs (xt$id, name) VALUES (1, 'two');" />
  <Query q={
`SELECT d.xt$id, d.name, d.xt$system_from
  FROM docs FOR ALL VALID_TIME AS d
  ORDER BY d.xt$id, d.xt$system_from`} />
</Fiddle>

## Lone Transaction

If you have a transaction on it's own then it won't be rendered with an editor:

<Fiddle>
  <Txs txs="INSERT INTO docs
            (xt$id, name)
            VALUES
            (1, 'one');" />
</Fiddle>

(It will still contribute to magicContext if you set one).

It will also render without an editor if you use a [Templated Query](#templated-queries).

## Magic Context

While of course you can use hidden `Txs` to include transactions previously executed on the page but that can get tedious.

Instead you can tell the component to look at transactions from *previous* fiddles on the page.
Note that it will only look for transactions from fiddles with the *same context id string* set.

For example:

<Fiddle magicContext="my-context">
  <Txs systemTime="2020-01-01"
       txs="INSERT INTO docs (xt$id, name) VALUES (1, 'one');" />
  <Query q="SELECT * FROM docs" />
</Fiddle>

Note that it we only have docs from this fiddle.

<Fiddle magicContext="my-context">
  <Txs systemTime="2020-01-02"
       txs="
    INSERT INTO docs (xt$id, name) VALUES (1, 'two');
    INSERT INTO docs (xt$id, name) VALUES (2, 'three');" />
  <Query q={
`SELECT d.xt$id, d.name, d.xt$system_from
  FROM docs FOR ALL VALID_TIME AS d
  ORDER BY d.xt$id, d.xt$system_from`} />
</Fiddle>

Note that now we have the transactions from the previous fiddle :)

This fiddle uses a different context id, so it will not use the context of previous fiddles:

<Fiddle magicContext="different-context">
  <Txs systemTime="2020-01-02"
       txs="
    INSERT INTO docs (xt$id, name) VALUES (1, 'two');
    INSERT INTO docs (xt$id, name) VALUES (2, 'three');" />
  <Query q={
`SELECT d.xt$id, d.name, d.xt$system_from
  FROM docs FOR ALL VALID_TIME AS d
  ORDER BY d.xt$id, d.xt$system_from`} />
</Fiddle>


## Templated Queries

Having a full editor and asking a user to change it can be a lot. Instead you can use a query template:

import QueryTemplate from "@components/fiddle/template.astro"
import Range from "@components/fiddle/range.astro"

<Fiddle autoLoad magicContext="orders">
  <Txs txs="INSERT INTO orders
            (xt$id, name, count, xt$valid_from)
            VALUES
            (1, 'Bike',        4, DATE '2024-01-01'),
            (2, 'Ice Cream',   3, DATE '2024-01-02'),
            (3, 'Tennis Ball', 5, DATE '2024-01-03'),
            (4, 'Toy Gun',     2, DATE '2024-01-04'),
            (5, 'Blocks',      1, DATE '2024-01-05')" />
  <QueryTemplate q="SELECT *
                    FROM orders
                    LIMIT {{limit}}" />
  <Range name="limit" min={0} max={5} step={1} value={3} />
</Fiddle>

Query templates use [mustache](https://mustache.github.io/) templates.

Use [Inputs](#inputs) to set the state used to render the template.

It usually makes sense to set the `autoLoad` property when you have a query template.

## Inputs

Inputs set variables in the template using their `name` property.

<Fiddle autoLoad magicContext="orders">
  <QueryTemplate q="SELECT *
                    FROM orders
                    {{#enabled}}
                    LIMIT {{limit}}
                    {{/enabled}}" />
  <div class="flex flex-row gap-2">
    Limit:
    <Checkbox name="enabled" checked />
    <Range name="limit" min={0} max={5} step={1} value={3} />
  </div>
</Fiddle>

See [Available Inputs](#available-inputs) for a showcase.


## Outputs

By default, if no outputs are added a [table output](#table-output) is automatically appended to the fiddle.

You can override this by adding your own:

<Fiddle autoLoad magicContext="orders">
  <QueryTemplate q="SELECT *
                    FROM orders AS o
                    WHERE o.count > {{count}}
                    ORDER BY o.xt$id" />
  <Range name="count" min={0} max={6} step={2} value={0} />
  <OutputVega spec={{
    $schema: 'https://vega.github.io/schema/vega-lite/v5.json',
    data: { name: "table" },
    mark: "bar",
    encoding: {
      x: { field: 'xt$id', type: 'ordinal' },
      y: { field: 'count', type: 'quantitative' }
    }
  }} />
</Fiddle>

You can also have multiple if you want:

<Fiddle autoLoad magicContext="orders">
  <QueryTemplate q="SELECT *
                    FROM orders AS o
                    WHERE o.count > {{count}}
                    ORDER BY o.xt$id" />
  <Range name="count" min={0} max={6} step={2} value={0} />
  <div class="grid grid-cols-2 gap-1">
    <OutputVega spec={{
      $schema: 'https://vega.github.io/schema/vega-lite/v5.json',
      data: { name: "table" },
      mark: "bar",
      encoding: {
        x: { field: 'xt$id', type: 'ordinal' },
        y: { field: 'count', type: 'quantitative' }
      }
    }} />
    <OutputTable />
  </div>
</Fiddle>

See [Available Outputs](#available-outputs) for a showcase.

## Caveats

Please note that the fiddle expects **exactly one** query:

<Fiddle>
  <Txs txs="INSERT INTO docs (xt$id, name) VALUES (1, 'one')" />
  <Query q="SELECT * FROM docs" />
  <Txs txs="INSERT INTO docs (xt$id, name) VALUES (2, 'two')" />
  <Query q="this won't be run" />
</Fiddle>

The query is always run last:

<Fiddle>
  <Query q="SELECT * FROM docs" />
  <Txs txs="INSERT INTO docs (xt$id, name) VALUES (1, 'one')" />
</Fiddle>

## Styling Tips

As you'll have seen in the examples above, you can use tailwind to style the inputs.

This is handy for:

import Text from '@components/fiddle/text.astro';

<Fiddle autoLoad magicContext="orders">
  <QueryTemplate q="SELECT *
                    FROM orders AS o
                    WHERE {{#true}}true{{/true}}{{^true}}false{{/true}} {{#enableSearch}}AND o.name LIKE '%{{search}}%'{{/enableSearch}}
                    LIMIT {{limit}}" />

  Putting a label beside an input:
  <div class="flex flex-row gap-2 items-center">
    My checkbox:
    <Checkbox name="true" checked />
  </div>

  <hr class="border-b border-gray-300 dark:border-gray-600" />

  Styling the input itself:
  <Range class="w-full" name="limit" min="0" max="5" value="3" />

  <hr class="border-b border-gray-300 dark:border-gray-600" />
  Organising inputs:
  <div class="flex flex-row gap-2 items-center">
    Search:
    <Checkbox name="enableSearch" checked />
    <Text name="search" />
  </div>
</Fiddle>

## Available Inputs

### Checkbox

A wrapper around the [checkbox input](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox).

import Checkbox from "@components/fiddle/checkbox.astro"

<Fiddle autoLoad magicContext="orders">
  <QueryTemplate q="SELECT *
                    FROM orders AS o
                    -- Watch as the below changes:
                    {{#useWhere}}
                    WHERE o.count < 3
                    {{/useWhere}}
                    ORDER BY o.xt$id" />
  <Checkbox name="useWhere" checked />
</Fiddle>

### Range

You can provide a `min`, `max`, `step` and `value` to specify a range.
Can be a float or integer.

<Fiddle autoLoad magicContext="orders">
  <QueryTemplate q="SELECT *
                    FROM orders AS o
                    WHERE o.count > {{count}}
                    ORDER BY o.xt$id" />
  <Range name="count" min={0} max={6} step={2} />
</Fiddle>

### DateRange

import DateRange from '@components/fiddle/date-range.astro';

A customised range input specifically for outputting dates with two varieties:

You can provide a `start`, `stop` and `step` amount to have a full range of dates:

<Fiddle autoLoad magicContext="orders">
  <QueryTemplate q="SELECT o.xt$id, o.count, o.name, o.xt$valid_from
                    FROM orders FOR VALID_TIME AS OF {{validTime}} AS o
                    ORDER BY o.xt$id" />
  <DateRange name="validTime" start="2024-01-01" stop="2024-01-05" step="1 day" value="2024-01-04" />
</Fiddle>

Or you can provide an array of dates:

<Fiddle autoLoad magicContext="orders">
  <QueryTemplate q="SELECT o.xt$id, o.count, o.name, o.xt$valid_from
                    FROM orders FOR VALID_TIME AS OF {{validTime}} AS o
                    ORDER BY o.xt$id" />
  <DateRange name="validTime" dates={["2024-01-01","2024-01-02","2024-01-05"]} value="2024-01-05" />
</Fiddle>

### Text

A textbox element that allows the user to type in whatever they like:

<Fiddle autoLoad magicContext="orders">
  <QueryTemplate q="SELECT *
                    FROM orders AS o
                    WHERE o.name LIKE '%{{name}}%'
                    ORDER BY o.xt$id" />
  <Text name="name" value="Toy" />
</Fiddle>


## Available Outputs

### Table

import OutputTable from '@components/fiddle/output-table.astro';

The same table used in the Fiddle. Added by default if no output is provided.

<Fiddle autoLoad magicContext="orders">
  <QueryTemplate q="SELECT *
                    FROM orders AS o
                    WHERE o.count > {{count}}
                    ORDER BY o.xt$id" />
  <Range name="count" min={0} max={6} step={2} />
  <OutputTable />
</Fiddle>

### Vega

import OutputVega from '@components/fiddle/output-vega.astro';

Displays a vega chart. You can specify a chart spec using the `spec` arg.

Data is provided through a dataset named `table`.

<Fiddle autoLoad magicContext="orders">
  <QueryTemplate q="SELECT *
                    FROM orders AS o
                    WHERE o.count > {{count}}
                    ORDER BY o.xt$id" />
  <Range name="count" min={0} max={6} step={2} value={0} />
  <OutputVega spec={{
    $schema: 'https://vega.github.io/schema/vega-lite/v5.json',
    data: { name: "table" },
    mark: "bar",
    encoding: {
      x: { field: 'xt$id', type: 'ordinal' },
      y: { field: 'count', type: 'quantitative' }
    }
  }} />
</Fiddle>
